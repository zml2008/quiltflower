// Copyright 2000-2021 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

import org.jetbrains.java.decompiler.build.JasmCompile

plugins {
  id 'jacoco'
  id 'java-test-fixtures'
  id 'groovy'
  id 'scala'
  id 'com.github.johnrengelman.shadow' version '8.1.1'
  id 'org.jetbrains.kotlin.jvm' version '1.6.21'
  id 'org.vineflower.convention.publishing'
}

allprojects {
  apply plugin: 'org.vineflower.convention.base'
  ext.isArm = System.getProperty('os.arch') == 'aarch64'

}

base.archivesBaseName = 'vineflower'
version = '1.10.0'

def ENV = System.getenv()
version = version + (ENV.GITHUB_ACTIONS ? "" : "+local")
version = version + (ENV.STATUS == "snapshot" ? "-SNAPSHOT" : "")

sourceSets {
  main.java.srcDirs 'src'
  test.java.srcDirs 'test'
  testFixtures.java.srcDirs 'testFixtures'
  testDataGroovy.groovy.srcDirs files("testData/src/groovy/")
  testDataKotlin.kotlin.srcDirs files("testData/src/kt/")
  testDataScala.scala.srcDirs files("testData/src/scala")
}

dependencies {
  testImplementation("org.junit.jupiter:junit-jupiter-params")

  testImplementation("org.hamcrest:hamcrest:${project.hamcrest}")

  testFixturesImplementation(platform("org.junit:junit-bom:${project.junit_bom}"))
  testFixturesImplementation("org.junit.jupiter:junit-jupiter-params")
  testFixturesImplementation("org.hamcrest:hamcrest:${project.hamcrest}")

  testDataGroovyImplementation("org.codehaus.groovy:groovy:${project.groovy}")
  testDataKotlinImplementation platform("org.jetbrains.kotlin:kotlin-bom")
  testDataKotlinImplementation "org.jetbrains.kotlin:kotlin-stdlib-jdk8"

  testDataScalaImplementation("org.scala-lang:scala3-library_3:${project.scala_library}")
  testRuntimeOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk8"
}


jacocoTestReport.dependsOn(test)
build.dependsOn(jacocoTestReport)
jacocoTestReport {
  reports {
    xml.required = true
  }
}

tasks.withType(JavaCompile).configureEach {
  options.deprecation = true
}

task testDataClasses {
  group = 'build'
}
testClasses.dependsOn(testDataClasses)

void createJavaTestDataSet(int version, String suffix = "", List<String> compilerArgs = []) {
  sourceSets.create("testDataJava${version}${suffix}") {
    it.java.srcDirs file("testData/src/java${version}${suffix.toLowerCase()}")
  }
  tasks.named("compileTestDataJava${version}${suffix}Java") {
    destinationDirectory = file("testData/classes/java${version}${suffix.toLowerCase()}")
    if (vineflower.isArm64.get() && version > 8 && version < 11) {
      // On ARM systems, a more limited set of JVM versions are available
      // We'll accept the `--release` flag so development is at least somewhat possible
      javaCompiler = javaToolchains.compilerFor {
        languageVersion = JavaLanguageVersion.of(11)
      }
      options.release = version
    } else {
      javaCompiler = javaToolchains.compilerFor {
        languageVersion = JavaLanguageVersion.of(version)
      }
    }

    options.compilerArgs = compilerArgs
  }
  testDataClasses.dependsOn("testDataJava${version}${suffix}Classes")
}

def testJavaRuntimes = [:]

[8, 9, 11, 16, 17].forEach { version ->
    def runtimeVersion = isArm && version > 8 && version < 11 ? 11 : version
    createJavaTestDataSet(version)
    testJavaRuntimes[version] = javaToolchains.launcherFor {
        languageVersion = JavaLanguageVersion.of(runtimeVersion)
    }
}
[16, 17, 19].forEach { version -> createJavaTestDataSet(version, "Preview", ["--enable-preview"]) }
[8, 16].forEach { version -> createJavaTestDataSet(version, "NoDebug", ["-g:none"])}

task compileTestDataJasm(type: JasmCompile) {
  source = fileTree("testData/src/jasm/")
  destinationDirectory = file("testData/classes/jasm/")
  options.compilerArgs += ["-g"]
}
task testDataJasmClasses {
  group = 'build'
}
testDataJasmClasses.dependsOn(compileTestDataJasm)
testDataClasses.dependsOn(testDataJasmClasses)

compileTestDataGroovyGroovy {
  destinationDirectory = file("testData/classes/groovy")
}
testDataClasses.dependsOn(testDataGroovyClasses)

compileTestDataKotlinKotlin {
  destinationDirectory = file("testData/classes/kt")
}
testDataClasses.dependsOn(testDataKotlinClasses)

compileTestDataScalaScala {
  destinationDirectory = file("testData/classes/scala")
}
testDataClasses.dependsOn(testDataScalaClasses)

class TestDataRuntimesProvider implements CommandLineArgumentProvider {
    @Nested
    final MapProperty<String, JavaLauncher> launchers
    
    @Inject
    TestDataRuntimesProvider(final ObjectFactory objects) {
        this.launchers = objects.mapProperty(Integer, JavaLauncher)
    }
     
    @Override
    Iterable<String> asArguments() {
        def result = []
        this.launchers.get().each { k, v ->
            result << "-Djava.${k}.home=${v.metadata.installationPath.asFile.absolutePath}"
        }
        return result
    }
}

test {
  maxHeapSize = "512M"

  systemProperty "DOT_EXPORT_DIR", System.getProperty("DOT_EXPORT_DIR", null)
  systemProperty "DOT_ERROR_EXPORT_DIR", System.getProperty("DOT_ERROR_EXPORT_DIR", null)
  systemProperty "VALIDATE_DECOMPILED_CODE", System.getProperty("VALIDATE_DECOMPILED_CODE", "false")
  
  def provider = objects.newInstance(TestDataRuntimesProvider)
  testJavaRuntimes.each { k, v ->
      provider.launchers.put(k, v)
  }
  jvmArgumentProviders << provider
}

jar {
  archiveClassifier = "slim"
  from sourceSets.main.output

  manifest {
    attributes (
      'Main-Class': 'org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler',
      'Implementation-Name': "Vineflower",
      'Implementation-Version': project.version
    )
  }
}

task sourceJar(type:Jar) {
  archiveClassifier = "sources"
  from sourceSets.main.allSource
}

def allJar = tasks.register('allJar', Jar) {allJar ->
  archiveClassifier.set('')
  from sourceSets.main.output

  manifest {
    attributes (
      'Main-Class': 'org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler',
      'Implementation-Name': "Vineflower",
      'Implementation-Version': project.version
    )
  }

  subprojects.each {
    allJar.from(it.tasks.named(it.plugins.hasPlugin('com.github.johnrengelman.shadow') ? 'shadowJar' : 'jar').get().outputs) {
      into 'META-INF/plugins/'
    }
  }
}
build.dependsOn(allJar)

publishing.publications.mavenJava {
  pom {
    name = 'Vineflower'
  }
}